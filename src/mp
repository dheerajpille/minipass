#!/bin/bash

# Creates initial password system file directory
# Modulaize a bit more of the repetitive stuff
# Make variables capitalized?
cmd_init() {
	if [ "$#" -gt 0 ] ; then
		func_err "Too many arguments."
	elif [ -d "$HOME"/.minipass/ ] ; then
		func_err "Password system exists for" "$USER"
	else
		mkdir $HOME/.minipass/
		func_msg "Password system created for" "$USER"
	fi
}

# Inserts password for specified domain to password system
cmd_ins() {
	local ECHO=false
	local MULTILINE=false

	local opts=`getopt -o em --long echo,multiline -n 'parse-options' -- "$@"`
	eval set -- "$opts"

	while true ; do
		case "$1" in
		    -e | --echo      )			 ECHO=true; shift ;;
		    -m | --multiline )		MULTILINE=true; shift ;;
			--               )				 shift; break ;;
			*                )				 shift; break ;;
		  esac
	done

	# Enables echo option if multiline is flagged
	if [ "$multiline" = true ] ; then
		echo=true
	fi

	if [ -d "$HOME"/.minipass/ ] ; then
		if [ "$#" -eq 1 ] ; then
			if [ ! -d "$HOME"/.minipass/"$1"/ ] ; then
				mkdir "$HOME"/.minipass/"$1"/
			fi
			while true ; do
				printf "Username: "
				read USERNAME
				if [ -z "$USERNAME" ] ; then
					echo "Username is empty. Please enter a non-empty username."
				else 
					break
				fi
			done
			if [ -f "$HOME"/.minipass/"$1"/"$USERNAME".gpg ] ; then 
				func_err "Username exists for domain" "$1"
			else
				# Add check if password is empty?
				printf "Password: "
				if [ "$ECHO" = true ] ; then
					if [ "$MULTILINE" = true ] ; then
						PASSWORD=$(</dev/stdin)
					else
						read -r PASSWORD
					fi
				else
					read -r -s PASSWORD && echo
				fi
				echo -n "$PASSWORD" > "$HOME"/.minipass/"$1"/"$USERNAME"
				gpg --encrypt --default-recipient-self "$HOME"/.minipass/"$1"/"$USERNAME"
				# Maybe do this in temporary files, since this shows up in trash currently
				rm "$HOME"/.minipass/"$1"/"$USERNAME"
			fi 
		else
			func_err "Incorrect number of arguments"
		fi
	else
		func_err "Password system nonexistant for" "$USER" 
	fi
}

# Shows password for specified domain and username/login credentials
cmd_show() {
	if [ "$#" -eq 2 ] 
	then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] ; then
			gpg -q --output "$HOME"/.minipass/"$1"/"$2" --decrypt "$HOME"/.minipass/"$1"/"$2".gpg
			cat "$HOME"/.minipass/"$1"/"$2" ; echo ''
			rm "$HOME"/.minipass/"$1"/"$2"
		else
			func_err "Password nonexistant for domain and username"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Generates random password
cmd_gen() {
	# add alphanumeric flag
	local LOWER_CHECK='^.*[a-z]+.*$'
	local UPPER_CHECK='^.*[A-Z]+.*$'
	local NUMBER_CHECK='^.*[0-9]+.*$'
	local SPECIAL_CHECK='^.*[!#\$%\&\(\)*+,-./:\;\<\=\>?@\\^_\`{\|}~]+.*$'
	local LOWER_STATE=false
	local UPPER_STATE=false
	local NUMBER_STATE=false
	local SPECIAL_STATE=false

	if [ "$#" -eq 1 ] ; then
		if [[ "$1" =~ $num_regex && "$1" -ge 4 ]]
		then
			while true
			do
				local gen_pwd="$(head /dev/urandom | tr -dc a-zA-Z0-9!#\$%\&\(\)*+,-./:\;\<\=\>?@\\^_\`{\|}~ | head -c $1 ; echo '')"
				if [[ "$gen_pwd" =~ $LOWER_CHECK ]] ; then 
					LOWER_STATE=true
				else
					LOWER_STATE=false
				fi
				if [[ "$gen_pwd" =~ $UPPER_CHECK ]] ; then
					UPPER_STATE=true
				else
					UPPER_STATE=false
				fi
				if [[ "$gen_pwd" =~ $NUMBER_CHECK ]] ; then
					NUMBER_STATE=true
				else
					NUMBER_STATE=false
				fi
				if [[ "$gen_pwd" =~ $SPECIAL_CHECK ]] ; then
					SPECIAL_STATE=true
				else
					SPECIAL_STATE=false
				fi
				if [ "$LOWER_STATE" = true ] && [ "$UPPER_STATE" = true ] && [ "$NUMBER_STATE" = true ] && [ "$SPECIAL_STATE" = true ] ; then
					break
				fi
			done
			echo "$gen_pwd"
		else
			func_err "Expected valid numerical argument greater than or equal to 4"
		fi
	else
		echo "$1"
		func_err "Incorrect number of arguments"
	fi
}

# Removes password from specified domain from password system
cmd_rm() {
	local INPUT=""
	local YES=false

	local opts=`getopt -o y --long yes -n 'parse-options' -- "$@"`
	eval set -- "$opts"

	while true ; do
		case "$1" in
		    -y | --yes )		YES=true; shift ;;
			--         )           shift; break ;;
			*          )           shift; break ;;
		  esac
	done

	if [ ! -d "$HOME"/.minipass/ ] ; then
		func_err "Password system nonexistant for" "$USER" 
		return
	fi

	if [ "$#" -eq 0 ] ; then
		if [ "$YES" = true ] ; then
			rm "$HOME"/.minipass
		else
			while true ; do
				printf "Remove password system for $USER? (y/n): "
				read INPUT
				if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
					rm "$HOME"/.minipass
					break
				elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
					break
				else
					func_err "I don't understand your input..."
				fi 
			done
		fi
	elif [ "$#" -eq 1 ] ; then
		if [ -f "$HOME"/.minipass/"$1" ] ; then
			if [ "$YES" = true ] ; then
				rm "$HOME"/.minipass/"$1"
			else
				while true ; do
					printf "Remove password for $2 in domain $1? (y/n): "
					read INPUT
					if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
						rm "$HOME"/.minipass/"$1"
						break
					elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
						break
					else
						func_err "I don't understand your input..."
					fi 
				done
			fi
		else
			func_err "Domain $1 nonexistant in password system"
		fi
	elif [ "$#" -eq 2 ] ; then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] ; then
			if [ "$YES" = true ] ; then
				rm "$HOME"/.minipass/"$1"/"$2".gpg
			else
				while true ; do
					printf "Remove password for $2 in domain $1? (y/n): "
					read INPUT
					if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
						rm "$HOME"/.minipass/"$1"/"$2".gpg
						break
					elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
						break
					else
						func_err "I don't understand your input..."
					fi 
				done
			fi
		else
			func_err "Username $2 nonexistant for domain $1"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Displays messages from program
func_msg() {
	echo "$@"
}

# Catches/displays error messages from program
func_err() {
	echo "Error:" "$@"
}

case $1 in
	init	| initialize ) shift; cmd_init    "$@" ;;
	ins     | insert     ) shift; cmd_ins     "$@" ;;
	gen     | generate   ) shift; cmd_gen     "$@" ;;
	show                 ) shift; cmd_show    "$@" ;;
	rm      | remove     ) shift; cmd_rm      "$@" ;;
	*                    ) shift; func_err "Unknown command: please use mp help for more details" ;;
esac

exit 0