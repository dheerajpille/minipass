#!/bin/bash

# Displays messages from program
func_msg() {
	echo "$@"
}

# Catches/displays error messages from program
func_err() {
	echo "Error:" "$@"
}

# Exits script if password system is not found
func_sys_check() {
	if [ ! -d "$HOME"/.minipass ]
	then
		func_err "Password system nonexistant for" "$USER" 
		exit 1
	fi
}

# Exits script if number of arguments is invalid
func_arg_check() {
	echo "$#"
	func_err "Incorrect number of arguments. Expected array arguments"
	exit 1
}

# Creates initial password system file directory
cmd_init() {
	if [ "$#" -gt 0 ] ; then
		func_err "Too many arguments."
	elif [ -d "$HOME"/.minipass/ ] ; then
		func_err "Password system exists for" "$USER"
	else
		mkdir $HOME/.minipass/
		func_msg "Password system created for" "$USER"
	fi
}

# Inserts password for specified domain to password system
cmd_ins() {
	local ECHO=false
	local MULTILINE=false

	local opts=`getopt -o em --long echo,multiline -n 'parse-options' -- "$@"`
	eval set -- "$opts"

	while true ; do
		case "$1" in
		    -e | --echo      )      ECHO=true; shift ;;
		    -m | --multiline ) MULTILINE=true; shift ;;
			--               )          shift; break ;;
			*                )          shift; break ;;
		  esac
	done

	# Sets echo option if multiline is flagged
	if [ "$MULTILINE" = true ] ; then
		ECHO=true
	fi

	func_sys_check

	if [ "$#" -eq 1 ] ; then
		if [ ! -d "$HOME"/.minipass/"$1"/ ] ; then
			mkdir "$HOME"/.minipass/"$1"/
		fi
		while true ; do
			printf "Username: "
			read USERNAME
			if [ -z "$USERNAME" ] ; then
				func_msg "Username is empty. Please enter a non-empty username."
			else 
				break
			fi
		done
		# TODO: add check if password is empty?
		printf "Password: "
		if [ "$ECHO" = true ] ; then
			if [ "$MULTILINE" = true ] ; then
				PASSWORD=$(</dev/stdin)
			else
				read -r PASSWORD
			fi
		else
			read -r -s PASSWORD && echo
		fi
		echo -n "$PASSWORD" > "$HOME"/.minipass/"$1"/"$USERNAME"
		gpg --encrypt --default-recipient-self "$HOME"/.minipass/"$1"/"$USERNAME"
		# TODO: maybe do this in temporary files, since this shows up in trash currently
		# TODO: see if this still exists or may have been fixed
		rm "$HOME"/.minipass/"$1"/"$USERNAME"
	else
		func_err "Incorrect number of arguments"
	fi
}

# Shows password for specified domain and username/login credentials
cmd_show() {
	func_sys_check
	
	if [ "$#" -eq 2 ] 
	then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] ; then
			gpg -q --output "$HOME"/.minipass/"$1"/"$2" --decrypt "$HOME"/.minipass/"$1"/"$2".gpg
			cat "$HOME"/.minipass/"$1"/"$2" ; echo ''
			rm "$HOME"/.minipass/"$1"/"$2"
		else
			func_err "Password nonexistant for domain and username"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Generates random password
cmd_gen() {
	local LOWER_CHECK='^.*[a-z]+.*$'
	local UPPER_CHECK='^.*[A-Z]+.*$'
	local NUMBER_CHECK='^.*[0-9]+.*$'
	local SPECIAL_CHECK='^.*[!#\$%\&\(\)*+,-./:\;\<\=\>?@\\^_\`{\|}~]+.*$'
	local LOWER_STATE=false
	local UPPER_STATE=false
	local NUMBER_STATE=false
	local SPECIAL_STATE=false

	local ALPHANUMERIC=false
	local ECHO=false

	local opts=`getopt -o a --long alphanumeric -n 'parse-options' -- "$@"`
	eval set -- "$opts"

	# TODO: fix -e not being read (parse-options) failing
	while true ; do
		case "$1" in
			-a | --alphanumeric )	 ALPHANUMERIC=true; shift ;;
		    -e | --echo         )            ECHO=true; shift ;;
			--              	)				 shift; break ;;
			*                	)				 shift; break ;;
		  esac
	done

	func_sys_check

	# echo "$ALPHANUMERIC"
	# echo "$ECHO"

	if [ "$#" -eq 2 ] ; then
		if [[ "$1" =~ $num_regex && "$1" -ge 4 ]] ; then
			while true ; do
				if [ "$ALPHANUMERIC" = true ] ; then
					local GEN_PWD="$(head /dev/urandom | tr -dc a-zA-Z0-9 | head -c $1 ; echo '')"
				else
					local GEN_PWD="$(head /dev/urandom | tr -dc a-zA-Z0-9!#\$%\&\(\)*+,-./:\;\<\=\>?@\\^_\`{\|}~ | head -c $1 ; echo '')"
				fi
				if [[ "$GEN_PWD" =~ $LOWER_CHECK ]] ; then 
					LOWER_STATE=true
				else
					LOWER_STATE=false
				fi
				if [[ "$GEN_PWD" =~ $UPPER_CHECK ]] ; then
					UPPER_STATE=true
				else
					UPPER_STATE=false
				fi
				if [[ "$GEN_PWD" =~ $NUMBER_CHECK ]] ; then
					NUMBER_STATE=true
				else
					NUMBER_STATE=false
				fi
				if [[ "$GEN_PWD" =~ $SPECIAL_CHECK ]] ; then
					SPECIAL_STATE=true
				else
					SPECIAL_STATE=false
				fi
				if [ "$LOWER_STATE" = true ] && [ "$UPPER_STATE" = true ] && [ "$NUMBER_STATE" = true ] ; then
					if [ "$ALPHANUMERIC" = true ] || [ "$SPECIAL_STATE" = true ] ; then 
						break
					fi
				fi
			done
			if [ ! -d "$HOME"/.minipass/"$2"/ ] ; then
				mkdir "$HOME"/.minipass/"$2"/
			fi
			while true ; do
				printf "Username: "
				read USERNAME
				if [ -z "$USERNAME" ] ; then
					func_msg "Username is empty. Please enter a non-empty username."
				else 
					break
				fi
			done
			echo -n "$GEN_PWD" > "$HOME"/.minipass/"$2"/"$USERNAME"
			gpg --encrypt --default-recipient-self "$HOME"/.minipass/"$2"/"$USERNAME"
			rm "$HOME"/.minipass/"$2"/"$USERNAME"
			if [ "$ECHO" = true ] ; then
				echo "$GEN_PWD"
			fi
		else
			func_err "Expected valid numerical argument greater than or equal to 4"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Removes password from specified domain from password system
cmd_rm() {
	local FORCE=false

	local opts=`getopt -o f --long force -n 'parse-options' -- "$@"`
	eval set -- "$opts"

	while true ; do
		case "$1" in
		    -f | --force )		FORCE=true; shift ;;
			--           )           shift; break ;;
			*            )           shift; break ;;
		esac
	done

	func_sys_check

	if [ "$#" -eq 0 ] ; then
		if [ "$FORCE" = true ] ; then
			rm -rf "$HOME"/.minipass
		else
			while true ; do
				printf "Remove password system for $USER? (y/n): "
				read INPUT
				if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
					rm -rf "$HOME"/.minipass
					break
				elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
					break
				else
					func_err "I don't understand your input..."
				fi 
			done
		fi
	elif [ "$#" -eq 1 ] ; then
		if [ -d "$HOME"/.minipass/"$1" ] ; then
			if [ "$FORCE" = true ] ; then
				rm -rf "$HOME"/.minipass/"$1"
			else
				while true ; do
					printf "Remove all passwords in domain $1? (y/n): "
					read INPUT
					if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
						rm -rf "$HOME"/.minipass/"$1"
						break
					elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
						break
					else
						func_err "I don't understand your input..."
					fi 
				done
			fi
		else
			func_err "Domain $1 nonexistant in password system"
		fi
	elif [ "$#" -eq 2 ] ; then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] ; then
			if [ "$FORCE" = true ] ; then
				rm -rf "$HOME"/.minipass/"$1"/"$2".gpg
			else
				while true ; do
					printf "Remove password for $2 in domain $1? (y/n): "
					read INPUT
					if [[ "$INPUT" = [yY] ]] || [[ "$INPUT" = [yY][eE][sS] ]] ; then
						rm -rf "$HOME"/.minipass/"$1"/"$2".gpg
						break
					elif [[ "$INPUT" = [nN] ]]|| [[ "$INPUT" = [nN][oO] ]] ; then
						break
					else
						func_err "I don't understand your input..."
					fi 
				done
			fi
		else
			func_err "Username $2 nonexistant for domain $1"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Displays content of password system as a tree
cmd_tree() {
	func_sys_check

	if [ "$#" -eq 0 ]; then
		tree "$HOME"/.minipass/	
	elif [ "$#" -eq 1 ]; then
		if [ -d "$HOME"/.minipass/"$1" ]; then
			tree "$HOME"/.minipass/"$1"
		else
			func_err "$1 directory not found for" "$USER"
		fi
	else
		func_err "Incorrect number of arguments"
	fi
}

# Shows all available commands
cmd_help() {
	echo "TODO"
}

# Shows minipass version information
cmd_ver() {
	echo "mp/minipass v1.0.0 (c) 2018-2018 by Dheeraj Pille"
}

case $1 in
	init    | initialize ) shift; cmd_init    "$@" ;;
	ins     | insert     ) shift; cmd_ins     "$@" ;;
	gen     | generate   ) shift; cmd_gen     "$@" ;;
	show                 ) shift; cmd_show    "$@" ;;
	rm      | remove     ) shift; cmd_rm      "$@" ;;
	tree                 ) shift; cmd_tree    "$@" ;;
	help    | --help     ) shift; cmd_help    "$@" ;;
	version | --version  ) shift; cmd_ver     "$@" ;;
	*                    ) shift; func_err    "Unknown command. Please use mp help for more details" ;;
	# TODO: how to output italics in terminal for mp help
esac

exit 0