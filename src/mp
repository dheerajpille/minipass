#!/bin/bash

#PROGRAM="${0##*/}"
#COMMAND=$1

# Add options later

# Creates initial password system file directory
cmd_init() {
	if [ "$#" -gt 0 ] 
	then
		cmd_err "Too many arguments."
	elif [ -d "$HOME"/.minipass/ ]
	then
		cmd_err "Password system exists for" "$USER"
	else
		mkdir $HOME/.minipass/
		cmd_msg "Password system created for" "$USER"
	fi
}

# Inserts password for specified domain to password system
cmd_ins() {
	if [ -d "$HOME"/.minipass/ ]
	then
		# Check for empty values in username/password
		if [ "$#" -eq 1 ]
		then
			if [ ! -d "$HOME"/.minipass/"$1"/ ]
			then
				mkdir "$HOME"/.minipass/"$1"/
			fi
			printf "Username: "
			read USERNAME
			if [ -f "$HOME"/.minipass/"$1"/"$USERNAME".gpg ]
			then 
				cmd_err "Username exists for domain" "$1"
			else
				printf "Password: "
				read -s PASSWORD && echo
				echo -n "$PASSWORD" > "$HOME"/.minipass/"$1"/"$USERNAME"
				gpg --encrypt --default-recipient-self "$HOME"/.minipass/"$1"/"$USERNAME"
				rm "$HOME"/.minipass/"$1"/"$USERNAME"
			fi 
		else
			cmd_err "Incorrect number of arguments"
		fi
	else
		cmd_err "Password system nonexistant for" "$USER" 
	fi
}

# Shows password for specified domain and username/login credentials
cmd_show() {
	if [ "$#" -eq 2 ] 
	then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] 
		then
			# try to bypass passphrase prompt
			gpg -q --output "$HOME"/.minipass/"$1"/"$2" --decrypt "$HOME"/.minipass/"$1"/"$2".gpg
			cat "$HOME"/.minipass/"$1"/"$2" ; echo ''
			rm "$HOME"/.minipass/"$1"/"$2"
		else
			cmd_err "Password nonexistant for domain and username"
		fi
	else
		cmd_err "Incorrect number of arguments"
	fi
}

# Generates random password
cmd_gen() {
	# add alphanumeric flag
	# check for 1 of of cap/low/digit/spec each in random position
	local lower_check='^.*[a-z]+.*$'
	local upper_check='^.*[A-Z]+.*$'
	local number_check='^.*[0-9]+.*$'
	local special_check='^.*[\!\#\$\%\&\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\`\{\|\}\~]+.*$'
	local regex='^.*[\$\!]+.*$'
	local str="1$2"
	echo "regex test"
	if [[ "$str" =~ $regex ]] 
	then 
		echo "lasdf"
	else 
		echo "bbd"
	fi
	local lower_state=false
	local upper_state=false
	local number_state=false
	local special_state=false
	if [ "$#" -eq 1 ]
	then
		if [[ "$1" =~ $num_regex && "$1" -ge 4 ]]
		then
			while true
			do
				local gen_pwd="$(head /dev/urandom | tr -dc a-zA-Z0-9\!\#\$\%\&\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\`\{\|\}\~ | head -c $1 ; echo '')"
				if [[ "$gen_pwd" =~ $lower_check ]]
				then 
					lower_state=true
				else
					lower_state=false
				fi
				if [[ "$gen_pwd" =~ $upper_check ]]
				then
					upper_state=true
				else
					upper_state=false
				fi
				if [[ "$gen_pwd" =~ $number_check ]]
				then
					number_state=true
				else
					number_state=false
				fi
				if [[ "$gen_pwd" =~ $special_check ]]
				then
					special_state=true
				else
					special_state=false
				fi
				if [[ "$lower_state"==true && "$upper_state"==true && "$number_state"==true && "$special_state"==true ]]
				then
					break
				fi
				echo "lol"
			done

			echo "$lower_state"
			echo "$upper_state"
			echo "$number_state"
			echo "$special_state"
			echo "$gen_pwd"
		else
			cmd_err "Expected valid numerical argument greater than or equal to 4"
		fi
	else
		echo "$1"
		cmd_err "Incorrect number of arguments"
	fi
}

cmd_rm() {
	# Add check to remove whoel domain maybe?				
	if [ "$#" -eq 2 ] 
	then
		if [ -f "$HOME"/.minipass/"$1"/"$2".gpg ] 
		then
			# Add option which bypasses prompt with -y
			while true
			do
				printf "Remove password for $2 in domain $1? (y/n): "
				read INPUT
				if [[ $INPUT = [yY] ]] || [[ $INPUT = [yY][eE][sS] ]]
				then
					rm "$HOME"/.minipass/"$1"/"$2".gpg
					break
				elif [[ $INPUT = [nN] ]]|| [[ $INPUT = [nN][oO] ]]
				then
					break
				else
					echo "I don't understand your input"
				fi 
			done
		else
			cmd_err "Password nonexistant for domain and username"
		fi
	else
		cmd_err "Incorrect number of arguments"
	fi
}

# Displays messages from program
cmd_msg() {
	echo "$@"
}

# Catches/displays error messages from program
cmd_err() {
	echo "Error:" "$@"
}

case $1 in
	init    | initialize ) shift; cmd_init    "$@";;
	ins     | insert     ) shift; cmd_ins     "$@";;
	gen     | generate   ) shift; cmd_gen     "$@";;
	show                 ) shift; cmd_show    "$@";;
	rm      | remove     ) shift; cmd_rm      "$@";;
	*                    ) shift; cmd_err "Unknown command: please use mp help for more details";;
esac

exit 0